\documentclass[../cheatSheetAlgoritmi.tex]{subfiles}
\begin{document}

\subsection{Esame 04/06/2018}
\textbf{Esercizio B4}\\
Siano dati un vettore $X$ contenente $n$ valori interi positivi distinti e due valori interi positivi $k, w$, con $k \leq n$. La \emph{somma massimale} $(k, w)-vincolata$ di $X$ è il più grande valore $v$ ottenibile come somma di non più di $k$ valori contenuti in $X$, tale che $v \leq w$. Formalmente
\begin{center}
	$v \leq w \land v = max_{S \subseteq \{1, ..., n\} \land \mid S \mid \leq k} \sum_{i \in S} X[i]$\\
\end{center}
Ad esempio, se $X = [12,13,11,6,23,19]$, $w = 27$, $k= 3$, il valore da restituire è pari a $25 = 12 + 13$ oppure $19 + 6$. Non è possibile ottenere 26 o 27, nemmeno utilizzando tre valori. Scrivere un algoritmo che dati in input $X,n,k,w$ restituisca il valore della somma massimale $(k, w)-vincolata$. Discutere informalmente la correttezza della   soluzione proposta e calcolare la complessità computazionale.\\
\textbf{Soluzione:}\\
Il problema descritto può essere risolto tramite programmazione dinamica: il primo passo per avviarsi alla risoluzione consiste nel definire correttamente il tipo di struttura che dovremo utilizzare per risolvere il problema. Se pensiamo di utilizzare una semplice matrice e di porre idealmente i $n$ valori sulle righe e il valori da 1 a $w$ sulle colonne come vincolo per impedirci di superare il numero in questione ci accorgiamo subito che non siamo in grado di tenere traccia di quanti numeri abbiamo sommato fino a questo momento (ricordiamoci che la somma deve essere $k-vincolata$ e che possiamo usare solo $k$ numeri per avvicinarci il più possibile al nostro $w$). Dunque abbiamo bisogno di una matrice a \emph{3 dimensioni} che possiamo definire nel modo seguente
\begin{equation*}
  	DP[i][j][k]=\begin{cases}
  	% Butta un occhio quando sei meno morto perchè forse nel caso in cui sfori servono i -infinito ma a sto punto non sei sicuro di nulla
  		0 & \text{$k = 0 \lor i < 0 \lor j < 0$}\\
  		max\{DP[i-1][k-1][k - X[i]], DP[]\} &\text{ ... }\\
    	robe & \text{altrimenti}
  	\end{cases}
\end{equation*} 
\begin{lstlisting}[caption=n-Colorazione (gapColoring)]
bool gapColoring(GRAPH G)
	SET C = Set()
	int[] color = new int[1...G.n]
	for i = 1 to G.n do
		C.insert(i)
		color[i] = -1
	return gapColoringRec(G, C, color, 1)
	
bool gapColoringRec(GRAPH G, SET S, int[] color, int u)
	foreach c $\in$ C do
		boolean ok = true
		foreach v $\in$ G.adj(u) do
			if color[v] > 0 and $\mid$ color[v] - c $\mid$ $<$ 2 then
				ok = false
		if ok then
			color[u] = c
			C.remove(c)
			if C.isEmpty() then
				return true
			foreach v $\in$ G.adj(u) do
				if color[v] < 0 and gapColoringRec(G, C, color, v) then
					return true
			C.insert(c)
			color[u] = -1
	return false
\end{lstlisting}
L'idea generale è questa: si visita il grafo tramite un meccanismo di backtrack, avendo a disposizione un insieme $C$ di colori ancora non utilizzati, rispettando le regole di colorazione e restituendo \textbf{true} se si riescono ad utilizzare tutti i colori. La complessità è ovviamente \emph{superpolinomiale}; nel caso limite di un grafo completo,è necessario provare tutte le permutazioni dei nodi a partire da 1, che sono $\mathcal{O}(n!)$; ovviamente, il controllo sulla regole dei valori consecutivi causerà il pruning di tanti casi, ma la soluzione resta comunque superpolinomiale.
\newpage
\end{document}