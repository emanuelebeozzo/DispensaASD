\documentclass[../cheatSheetAlgoritmi.tex]{subfiles}
\begin{document}

\chapter{Divide-et-impera}
\section{QuickSort}
\label{sec:quicksort}
\textbf{Problema}: Dato un vettore di ITEM A[1...n] e una coppia di indici start e end tali che 1  $\leq$ start  $\leq$ end  $\leq$ n, ordina il vettore A[i...n] in modo crescente. ITEM è un tipo di dato in cui è definito il confronto tra elementi.\\
\textbf{Soluzione}: l'algoritmo utilizza la tecnica divide-et-impera e si compone di due funzioni: la funzione pivot() si occupa, dato un sotto vettore, di definire un perno e di spostare a sinistra del perno tutti gli elementi più piccoli del perno stesso e  destra  gli elementi più grandi, mentre la funzione QuickSort() si occupa di richiamare la funzione in modo ricorsivo su sotto array di dimensione minore.\
\begin{lstlisting}[ caption=Quicksort]
int pivot(ITEM A[], int start, int end)
	ITEM P = A[start]
	int j = start
	for i = start+1 to end do
		if A[i]<p then 
			j = j+1
			A[i] $\leftrightarrow$ A[j]
	A[start] = A[j]
	A[j] = p	
	return j

void QuickSort(ITEM A[], int start, int end)
	if start < end then
		int j = pivot(A, start, end)
		QuickSort(A, start, j-1)
		QuickSort(A, j+1, end)		
\end{lstlisting}
\textbf{Costo computazionale}:
\begin{itemize}
 	\item Pivot: $\Theta$(\textit{n}) 
 	\item QuickSort: si comporta in modo diverso in base all'ordine degli elementi. Nel caso pessimo vale $\Theta$(\textit{n\textsuperscript{2}}), nel caso ottimo  $\Theta$(\textit{n log n}), mentre il caso medio è difficile da calcolare. 
\end{itemize}
\textbf{Specifica e assunzioni}: Metodi per la gestione della struttura. Assumiamo di memorizzare nella struttura degli interi e non degli oggetti e prevediamo che esista una associazione intero-oggetto memorizzata esternamente.\


\section{Gap}
\textbf{Problema}: Dato un vettore V di interi contenente n $\geq$ 2 elementi e tale che V[1] $<$ V[n], trovare la posizione di un gap nel vettore. In un vettore V contente almeno 2 interi, un gap è un indice i tale che 1 $<$ i $\leq$ n, tale che V[i-1] $<$ V[i]. Le condizioni poste nel problema di avere almeno 2 elementi e che valga V[1] $<$ V[n], garantiscono che ci sia almeno un gap.\\
\textbf{Soluzione}: implementazione ricorsiva con tecnica divide-et-impera. Uso una funzione wrapper per avere a disposizione più parametri.
 
\begin{lstlisting}[ caption=Gap]
int gap(int[] V, int n)
	return gapRect(V, 1, n)
	

int gapRec(int[] V, int i, int j)
	if j == i+1 then
		return j
	m = floor((i+j)/2)
	if V[m] < V[j] the
		return gapRec(V, m, j)
	else 
		return gapRec(V, i, m)
\end{lstlisting}
 
\end{document}